{"name": "Simple proof with Lean", "version": "0.1", "languages": ["en"], "translated_name": "0", "devmode": false, "library_zip_fn": "Simple proof with Lean-0.1-library.zip", "introData": {"name": "", "problemIndex": -1, "objects": [{"type": "text", "content": "1"}]}, "worlds": [{"name": "2", "levels": [{"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "3", "hidden": true}, {"type": "text", "content": "4"}, {"type": "lean", "content": "5", "hidden": false}, {"type": "text", "content": "6"}, {"type": "lean", "content": "7", "hidden": false}, {"type": "lean", "content": "8", "hidden": true}, {"type": "text", "content": "9"}, {"type": "theorem", "text": "10", "lean": "theorem decomposing_and (p q r : Prop) (h : (p \u2227 (q \u2227 r) \u2227 r)):\nq :=\n", "sideBar": false, "firstProofLineNumber": 58, "lastProofLineNumber": 62, "textBefore": "import data.int.basic tactic.pure_maths -- hide\n\n/-\n# Propositional logic\n## Level 1: And elimination\n\nLet $p$ and $q$ be propositions (mathematical statements). The formal statement $p \\land q$\n(read '$p$ conjunction $q$')\ncorresponds to the informal statement '$p$ and $q$'.\n\nSuppose you are given a hypothesis `h : p \u2227 q`. Then\n\n1. [left and elimination] `h.left` is a proof of `p` and\n2. [right and elimination] `h.right` is a proof of `q`.\n\n**Notation**: the symbol `\u2227` in Lean is typed `\\and`.\n\nexample: given we have apples and oranges, we have apples\n-/\n\nexample (apples oranges : Prop) (fruit : apples \u2227 oranges): apples :=\nbegin\n\nshow apples, from fruit.left,\n\nend\n\n/-\nmore difficult example. we can use and elimination repeatedly\n-/\n\nexample (p q r : Prop) (h\u2081 : ((p \u2227 q) \u2227 r) \u2227 p): p \u2227 q :=\nbegin\n\nhave h\u2082 : (p \u2227 q) \u2227 r, from and.elim_left h\u2081,\nfrom h\u2082.left,\n\n\nend\n\n\nnamespace exlean -- hide\n\n/-\n## Task\n\n1. Replace `sorry` below with a Lean proof using `have` together with left and right and elimination.\n\n-/\n\n/- Theorem : no-side-bar\nLet $p$, $q$, and $r$ be propositions. Assuming $h : (p \\land (q \\land r) \\land r)$,\nwe have $q$.\n-/\ntheorem decomposing_and (p q r : Prop) (h : (p \u2227 (q \u2227 r) \u2227 r)):\nq :=\nbegin\n", "proof": "\nhave h\u2082:(q \u2227 r) \u2227 r,  from h.right,\nhave h\u2083:(q \u2227 r), from h\u2082.left, \nshow q ,from h\u2083.left,\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide\n", "height": 5, "editorText": "sorry", "lineOffset": 57, "name": "decomposing_and", "statement": "(p q r : Prop) (h : (p \u2227 (q \u2227 r) \u2227 r)):\nq"}, {"type": "lean", "content": "11", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "12", "hidden": true}, {"type": "text", "content": "13"}, {"type": "lean", "content": "14", "hidden": false}, {"type": "lean", "content": "15", "hidden": true}, {"type": "text", "content": "16"}, {"type": "lean", "content": "17", "hidden": true}, {"type": "theorem", "text": "18", "lean": "theorem and.introo (p q r: Prop) (h\u2081: p)(h\u2082: q)(h\u2083: r): p \u2227 q \u2227 r :=\n", "sideBar": false, "firstProofLineNumber": 39, "lastProofLineNumber": 42, "textBefore": "import tactic.pure_maths -- hide\n\n/-\n# Propositional logic\n## Level 2: And introduction\n\nTo *prove* $p\\land q$ is to prove $p$ and prove $q$.\n\nIn Lean, if `h\u2081 : p` is a proof of `p` and `h\u2082 : q` is a proof of `q`, then `and.intro h\u2081 h\u2082`\nis a proof of `p \u2227 q`.\n-/\n\nexample (p q : Prop) (h\u2081 : p) (h\u2082 : q) : p \u2227 q :=\nbegin\n  from and.intro h\u2081 h\u2082,\nend\n\n\nnamespace exlean -- hide\n\n/-\n## Task\n\n1. Replace `sorry` below with a Lean proof using 'have' together with `and.intro`.\n\n**Notation**: Recall that `h\u2081` is written `h\\1`.\n-/\n\nvariables (p q r : Prop) -- hide\n\n/- Theorem : no-side-bar\nLet $p$, $q$, and $r$ be propositions. Assuming $h_1 : p$, $h_2 : q$, and $h_3 : r$, we have\n$h : p \\land q \\land r$.\n\nHint: try proving q \u2227 r first\n-/\ntheorem and.introo (p q r: Prop) (h\u2081: p)(h\u2082: q)(h\u2083: r): p \u2227 q \u2227 r :=\nbegin\n", "proof": "\nhave h\u2084: q \u2227 r, from and.intro h\u2082 h\u2083 ,\nfrom and.intro h\u2081 h\u2084,\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide\n", "height": 4, "editorText": "sorry", "lineOffset": 38, "name": "and.introo", "statement": "(p q r: Prop) (h\u2081: p)(h\u2082: q)(h\u2083: r): p \u2227 q \u2227 r"}, {"type": "lean", "content": "19", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "20", "hidden": true}, {"type": "text", "content": "21"}, {"type": "lean", "content": "22", "hidden": false}, {"type": "lean", "content": "23", "hidden": true}, {"type": "text", "content": "24"}, {"type": "theorem", "text": "25", "lean": "theorem and_intro_elim (p q r : Prop) (h\u2081 : (p \u2227 q) \u2227 r): p \u2227 r :=\n", "sideBar": false, "firstProofLineNumber": 37, "lastProofLineNumber": 42, "textBefore": "import data.int.basic tactic.pure_maths -- hide\n\n/- \n# Propositional logic\n## Level 3: Combining And Elimination and Introduction\n\nwe can combine the use of and elimination and and introduction for more complex proofs.\n\nexample: Given hypotheses $h\u2081: p$, and $h\u2082: q \u2227 r$, prove we have $p \u2227 q$.\n\nwe have $p$ from hypothesis $h\u2081$ and we have $q$ from left and elimination applied to $h\u2082$\n\ntherefore we have $p \u2227 q$ from and introduction applied to $p$ and $q$.\n-/\n\nexample (p q r: Prop) (h\u2081: p)(h\u2082: q \u2227 r): p \u2227 q :=\nbegin\n\nhave q, from h\u2082.left ,\nfrom and.intro h\u2081 q,\n\nend\n\nnamespace exlean -- hide\n\n/-\n## Task\n1. Replace `sorry` below with a Lean proof using `have` together with left and right and elimination and and introduction\n-/\n\n/- Theorem : no-side-bar\nLet $p$, $q$, and $r$ be propositions. Assuming $h : (p \\land q) \\land r $,\nwe have $p \\land r$.\n-/\ntheorem and_intro_elim (p q r : Prop) (h\u2081 : (p \u2227 q) \u2227 r): p \u2227 r :=\nbegin\n", "proof": "\nhave h\u2082 : p \u2227 q, from and.elim_left h\u2081,\nhave p, from h\u2082.left,\nhave r, from h\u2081.right,\nfrom and.intro p r,\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide\n", "height": 6, "editorText": "sorry", "lineOffset": 36, "name": "and_intro_elim", "statement": "(p q r : Prop) (h\u2081 : (p \u2227 q) \u2227 r): p \u2227 r"}, {"type": "lean", "content": "26", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "27", "hidden": true}, {"type": "text", "content": "28"}, {"type": "lean", "content": "29", "hidden": false}, {"type": "lean", "content": "30", "hidden": true}, {"type": "text", "content": "31"}, {"type": "theorem", "text": "32", "lean": "theorem or_or (p q r: Prop) (h: p): p \u2228 q \u2228 r :=\n", "sideBar": false, "firstProofLineNumber": 42, "lastProofLineNumber": 46, "textBefore": "import data.int.basic tactic.pure_maths -- hide\n\n/-\n# Propositional logic\n## Level 4: Or introduction\n\nLet $p$ and $q$ be propositions (mathematical statements). The formal statement $p \\lor q$\ncorresponds to the informal statement '$p$ or $q$'.\n\nTo *prove* $p \\lor q$ is to prove $p$ or prove $q$.\n\nSuppose you are given a hypothesis `h : p`. Then\n\n1. [left or introduction] `or.intro_left q h ` is a proof of `p` or `q`\n2. [right or introduction] `or.intro_right q h ` is a proof of `q` or `p`\n\n**Notation**: the symbol `\u2228` in Lean is typed `\\or`.\n\nexample: given p we have p or q\n-/\n\nexample (p q : Prop) (h: p): p \u2228 q :=\nbegin\n\n from or.intro_left q h,\n\nend\n\nnamespace exlean -- hide\n\n/-\n## Task\n1. Replace `sorry` below with a Lean proof using `have` together with or introduction\n-/\n\n/- Theorem : no-side-bar\nLet $p$, $q$, and $r$ be propositions. Assuming $h : p$,\nwe have $p \\lor q \\lor r$.\n-/\ntheorem or_or (p q r: Prop) (h: p): p \u2228 q \u2228 r :=\nbegin\n", "proof": "\nfrom or.intro_left (q \u2228 r) h,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide\n", "height": 5, "editorText": "sorry", "lineOffset": 41, "name": "or_or", "statement": "(p q r: Prop) (h: p): p \u2228 q \u2228 r"}, {"type": "lean", "content": "33", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "34", "hidden": true}, {"type": "text", "content": "35"}, {"type": "lean", "content": "36", "hidden": false}, {"type": "lean", "content": "37", "hidden": true}, {"type": "text", "content": "38"}, {"type": "theorem", "text": "39", "lean": "theorem multiple_and_or (p q r : Prop) (h\u2081 : (p \u2227 q) \u2227 r): (p \u2227 q) \u2228 r :=\n", "sideBar": false, "firstProofLineNumber": 39, "lastProofLineNumber": 44, "textBefore": "import data.int.basic tactic.pure_maths -- hide\n\n/-\n# Propositional logic\n## Level 5: And and Or question\n\nwe can use what we've learned to write more complex proofs.\n\nexample: given the hypothesis $h : p \u2227 q$, we have $p \u2228 q$\n\nwe have $p$ from left and elimination applied to $h$, and therefore we have $p \u2228 q$ from left or introduction applied to $q$ and $p$\n\nLean proof below.\n-/\n\nexample (p q : Prop) (h : p \u2227 q): p \u2228 q :=\nbegin\n\nhave p, from h.left,\nfrom or.intro_left q p,\n\nend\n\nnamespace exlean -- hide\n\n\n/-\n## Task\n1. Replace `sorry` below with a Lean proof using `have` together with and elimination/introduction and or introduction\n-/\n\n/- Theorem : no-side-bar\nLet $p$, $q$ and $r$ be propositions. Assuming $h : (p \\land q) \\land r$,\nwe have $(p \\land q) \\lor r$.\n-/\n\ntheorem multiple_and_or (p q r : Prop) (h\u2081 : (p \u2227 q) \u2227 r): (p \u2227 q) \u2228 r :=\nbegin\n", "proof": "\nhave h\u2082 : p \u2227 q, from and.elim_left h\u2081,\nfrom or.intro_left r h\u2082,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide\n", "height": 6, "editorText": "sorry", "lineOffset": 38, "name": "multiple_and_or", "statement": "(p q r : Prop) (h\u2081 : (p \u2227 q) \u2227 r): (p \u2227 q) \u2228 r"}, {"type": "lean", "content": "40", "hidden": true}]}]}, {"name": "41", "levels": [{"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "42", "hidden": true}, {"type": "text", "content": "43"}, {"type": "lean", "content": "44", "hidden": false}, {"type": "lean", "content": "45", "hidden": true}, {"type": "text", "content": "46"}, {"type": "theorem", "text": "47", "lean": "theorem add_commutes: \u2200 m : \u2115, \u2200 n : \u2115, m+n = m+n :=\n", "sideBar": false, "firstProofLineNumber": 43, "lastProofLineNumber": 47, "textBefore": "import data.int.basic tactic.pure_maths -- hide\n\n/-\n# Predicate logic\n##Level 1: Universal Quantifier\n\nThe Universal Quantifier, written  \u2200 (\\all in lean), means 'for all'. \n\nexample: show for all integers m, we have m = m\n\nto prove this for all statement, we use an arbitrary integer m and prove the statement is true for m, therefore proving for all integers,\nm = m follows by reflexivity\n\nlean proof is below.\n-/\n\nexample: \u2200 m : \u2115, m = m :=\nbegin\n\nassume m : \u2115, \nreflexivity,\n\n\nend \n\n\nnamespace exlean -- hide\n\n/-\n## Task\n1. Replace `sorry` below with a Lean proof using `assume'\n-/\n\n/- Theorem : no-side-bar\n\nfor all integers $m$ and $n$, $m + n = n + m$.\n\n\nHint: we can prove that a + b = b + a with 'ac_refl'\n-/\ntheorem add_commutes: \u2200 m : \u2115, \u2200 n : \u2115, m+n = m+n :=\nbegin\n", "proof": "\nassume m : \u2115, \nassume n : \u2115,\nac_refl,\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide\n", "height": 5, "editorText": "sorry", "lineOffset": 42, "name": "add_commutes", "statement": "\u2200 m : \u2115, \u2200 n : \u2115, m+n = m+n"}, {"type": "lean", "content": "48", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "49", "hidden": true}, {"type": "text", "content": "50"}, {"type": "lean", "content": "51", "hidden": false}, {"type": "lean", "content": "52", "hidden": true}, {"type": "text", "content": "53"}, {"type": "theorem", "text": "54", "lean": "theorem y_3 :\u2203 (y : \u2124), y  = 3 :=\n", "sideBar": false, "firstProofLineNumber": 40, "lastProofLineNumber": 42, "textBefore": "import data.int.basic tactic.pure_maths  tactic.interactive-- hide\n\n/-\n# Predicate logic\n## Level 2: Existential Quantifier\n\nThe Existential Quantifier, written  \u2203 (\\ex in lean), means 'there exists'\n\nexample: show there exists an integer $y$ such $y = 2$\n\nto prove this, we do the opposite of what we do for the universal quantifier, we must provide an integer $y$ such that the goal $'y = 2'$ is true, \n\nobviously we choose $y = 2$\n\nthen we must show that $2 = 2$, which is true by reflexivity.\n\nlean proof is below.\n-/\n\nexample :\u2203 (y : \u2124), y = 2 :=\nbegin\n  \n  use 2,\n  \nend\n\n\nnamespace exlean -- hide\n\n/-\n## Task\n1. Replace `sorry` below with a Lean proof using `use'\n-/\n\n/- Theorem : no-side-bar\nThere exists an integer $y$ such that $y = 3$\n-/\ntheorem y_3 :\u2203 (y : \u2124), y  = 3 :=\nbegin\n", "proof": "\nuse 3,\n", "proof_hint": "sorry", "textAfter": "\nend \n\nend exlean -- hide\n", "height": 3, "editorText": "sorry", "lineOffset": 39, "name": "y_3", "statement": "\u2203 (y : \u2124), y  = 3"}, {"type": "lean", "content": "55", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "56", "hidden": true}, {"type": "text", "content": "57"}, {"type": "lean", "content": "58", "hidden": false}, {"type": "lean", "content": "59", "hidden": true}, {"type": "text", "content": "60"}, {"type": "theorem", "text": "61", "lean": "theorem xplus1: \u2200 (x : \u2124), \u2203 (y : \u2124), x + 1 = y :=\n", "sideBar": false, "firstProofLineNumber": 37, "lastProofLineNumber": 41, "textBefore": "import data.int.basic tactic.pure_maths  tactic.interactive-- hide\n\n/-\n# Predicate logic\n## Level 3: Universal and Existential Quantifiers\n\nMany statements involve universal and existential quantiffiers.\n\nexample: for all integers $x$, there exists an integer $y$, such that $x + y = x + 3$\n\nwe first assume an abitrary integer $x$, then use 3 as the value of $y$, leaving us to prove $x + 3 = x + 3$ which is true by reflexivity.\n\nLean proof is below.\n-/\n\nexample : \u2200 (x : \u2124), \u2203 (y : \u2124), x + y = x + 3 :=\nbegin\n\nassume x: \u2124,\nuse 3,\n\nend \n\n\nnamespace exlean -- hide\n\n/-\n## Task\n1. Replace `sorry` below with a Lean proof using both 'assume' and `use'\n-/\n\n/- Theorem : no-side-bar\nfor all integers $x$, there exists an integer $y$, such that $x + 1 = y$\n-/\ntheorem xplus1: \u2200 (x : \u2124), \u2203 (y : \u2124), x + 1 = y :=\nbegin\n", "proof": "\nassume x: \u2124,\nuse (x + 1),\n\n", "proof_hint": "sorry", "textAfter": "\nend \n\nend exlean -- hide\n", "height": 5, "editorText": "sorry", "lineOffset": 36, "name": "xplus1", "statement": "\u2200 (x : \u2124), \u2203 (y : \u2124), x + 1 = y"}, {"type": "lean", "content": "62", "hidden": true}]}], "parents": [0]}], "texts": [["Simple proof with Lean", "# Simple proof in Lean, version 0.1\n\n## By Fred Kennedy\n\nInstructions: work through worlds 1 and 2 covering propositional and predicate logic respectively by reading examples and completing the proof at the end of each level.\n\n## Credits\n\nSource code based on \n<a href=\"https://gihanmarasingha.github.io/modern-maths-pages/\">Modern Maths Game</a> by Gihan Marasingha.\n\nThis game was made using the\n<a href=\"https://github.com/mpedramfar/Lean-game-maker\">Lean Game Maker</a> by Mohammad Pedramfar.\n\nIt uses ideas and special tactics from the \n<a href=\"https://www.ma.imperial.ac.uk/~buzzard/xena/natural_number_game/\">Natural Number Game</a>\nby Kevin Buzzard.\n\n<a href=\"https://leanprover.github.io/\" target=\"blank\">Lean</a> is an interactive theorem prover developed at Microsoft Research under the direction of\nLeonardo de Moura.\n\nMathlib, Lean's mathematical library, is developed by the <a href=\"https://leanprover-community.github.io/\" target=\"blank\">Lean community</a>.\n", "Propositional Logic", "import data.int.basic tactic.pure_maths -- hide\n", "# Propositional logic\n## Level 1: And elimination\n\nLet $p$ and $q$ be propositions (mathematical statements). The formal statement $p \\land q$\n(read '$p$ conjunction $q$')\ncorresponds to the informal statement '$p$ and $q$'.\n\nSuppose you are given a hypothesis `h : p \u2227 q`. Then\n\n1. [left and elimination] `h.left` is a proof of `p` and\n2. [right and elimination] `h.right` is a proof of `q`.\n\n**Notation**: the symbol `\u2227` in Lean is typed `\\and`.\n\nexample: given we have apples and oranges, we have apples\n", "example (apples oranges : Prop) (fruit : apples \u2227 oranges): apples :=\nbegin\nshow apples, from fruit.left,\nend\n", "more difficult example. we can use and elimination repeatedly\n", "example (p q r : Prop) (h\u2081 : ((p \u2227 q) \u2227 r) \u2227 p): p \u2227 q :=\nbegin\nhave h\u2082 : (p \u2227 q) \u2227 r, from and.elim_left h\u2081,\nfrom h\u2082.left,\nend\n", "namespace exlean -- hide\n", "## Task\n\n1. Replace `sorry` below with a Lean proof using `have` together with left and right and elimination.\n\n", "Let $p$, $q$, and $r$ be propositions. Assuming $h : (p \\land (q \\land r) \\land r)$,\nwe have $q$.\n", "end exlean -- hide\n", "import tactic.pure_maths -- hide\n", "# Propositional logic\n## Level 2: And introduction\n\nTo *prove* $p\\land q$ is to prove $p$ and prove $q$.\n\nIn Lean, if `h\u2081 : p` is a proof of `p` and `h\u2082 : q` is a proof of `q`, then `and.intro h\u2081 h\u2082`\nis a proof of `p \u2227 q`.\n", "example (p q : Prop) (h\u2081 : p) (h\u2082 : q) : p \u2227 q :=\nbegin\n  from and.intro h\u2081 h\u2082,\nend\n", "namespace exlean -- hide\n", "## Task\n\n1. Replace `sorry` below with a Lean proof using 'have' together with `and.intro`.\n\n**Notation**: Recall that `h\u2081` is written `h\\1`.\n", "variables (p q r : Prop) -- hide\n", "Let $p$, $q$, and $r$ be propositions. Assuming $h_1 : p$, $h_2 : q$, and $h_3 : r$, we have\n$h : p \\land q \\land r$.\nHint: try proving q \u2227 r first\n", "end exlean -- hide\n", "import data.int.basic tactic.pure_maths -- hide\n", "# Propositional logic\n## Level 3: Combining And Elimination and Introduction\n\nwe can combine the use of and elimination and and introduction for more complex proofs.\n\nexample: Given hypotheses $h\u2081: p$, and $h\u2082: q \u2227 r$, prove we have $p \u2227 q$.\n\nwe have $p$ from hypothesis $h\u2081$ and we have $q$ from left and elimination applied to $h\u2082$\n\ntherefore we have $p \u2227 q$ from and introduction applied to $p$ and $q$.\n", "example (p q r: Prop) (h\u2081: p)(h\u2082: q \u2227 r): p \u2227 q :=\nbegin\nhave q, from h\u2082.left ,\nfrom and.intro h\u2081 q,\nend\n", "namespace exlean -- hide\n", "## Task\n1. Replace `sorry` below with a Lean proof using `have` together with left and right and elimination and and introduction\n", "Let $p$, $q$, and $r$ be propositions. Assuming $h : (p \\land q) \\land r $,\nwe have $p \\land r$.\n", "end exlean -- hide\n", "import data.int.basic tactic.pure_maths -- hide\n", "# Propositional logic\n## Level 4: Or introduction\n\nLet $p$ and $q$ be propositions (mathematical statements). The formal statement $p \\lor q$\ncorresponds to the informal statement '$p$ or $q$'.\n\nTo *prove* $p \\lor q$ is to prove $p$ or prove $q$.\n\nSuppose you are given a hypothesis `h : p`. Then\n\n1. [left or introduction] `or.intro_left q h ` is a proof of `p` or `q`\n2. [right or introduction] `or.intro_right q h ` is a proof of `q` or `p`\n\n**Notation**: the symbol `\u2228` in Lean is typed `\\or`.\n\nexample: given p we have p or q\n", "example (p q : Prop) (h: p): p \u2228 q :=\nbegin\n from or.intro_left q h,\nend\n", "namespace exlean -- hide\n", "## Task\n1. Replace `sorry` below with a Lean proof using `have` together with or introduction\n", "Let $p$, $q$, and $r$ be propositions. Assuming $h : p$,\nwe have $p \\lor q \\lor r$.\n", "end exlean -- hide\n", "import data.int.basic tactic.pure_maths -- hide\n", "# Propositional logic\n## Level 5: And and Or question\n\nwe can use what we've learned to write more complex proofs.\n\nexample: given the hypothesis $h : p \u2227 q$, we have $p \u2228 q$\n\nwe have $p$ from left and elimination applied to $h$, and therefore we have $p \u2228 q$ from left or introduction applied to $q$ and $p$\n\nLean proof below.\n", "example (p q : Prop) (h : p \u2227 q): p \u2228 q :=\nbegin\nhave p, from h.left,\nfrom or.intro_left q p,\nend\n", "namespace exlean -- hide\n", "## Task\n1. Replace `sorry` below with a Lean proof using `have` together with and elimination/introduction and or introduction\n", "Let $p$, $q$ and $r$ be propositions. Assuming $h : (p \\land q) \\land r$,\nwe have $(p \\land q) \\lor r$.\n", "end exlean -- hide\n", "Predicate Logic", "import data.int.basic tactic.pure_maths -- hide\n", "# Predicate logic\n##Level 1: Universal Quantifier\n\nThe Universal Quantifier, written  \u2200 (\\all in lean), means 'for all'. \n\nexample: show for all integers m, we have m = m\n\nto prove this for all statement, we use an arbitrary integer m and prove the statement is true for m, therefore proving for all integers,\nm = m follows by reflexivity\n\nlean proof is below.\n", "example: \u2200 m : \u2115, m = m :=\nbegin\nassume m : \u2115, \nreflexivity,\nend \n", "namespace exlean -- hide\n", "## Task\n1. Replace `sorry` below with a Lean proof using `assume'\n", "for all integers $m$ and $n$, $m + n = n + m$.\nHint: we can prove that a + b = b + a with 'ac_refl'\n", "end exlean -- hide\n", "import data.int.basic tactic.pure_maths  tactic.interactive-- hide\n", "# Predicate logic\n## Level 2: Existential Quantifier\n\nThe Existential Quantifier, written  \u2203 (\\ex in lean), means 'there exists'\n\nexample: show there exists an integer $y$ such $y = 2$\n\nto prove this, we do the opposite of what we do for the universal quantifier, we must provide an integer $y$ such that the goal $'y = 2'$ is true, \n\nobviously we choose $y = 2$\n\nthen we must show that $2 = 2$, which is true by reflexivity.\n\nlean proof is below.\n", "example :\u2203 (y : \u2124), y = 2 :=\nbegin\n  use 2,\nend\n", "namespace exlean -- hide\n", "## Task\n1. Replace `sorry` below with a Lean proof using `use'\n", "There exists an integer $y$ such that $y = 3$\n", "end exlean -- hide\n", "import data.int.basic tactic.pure_maths  tactic.interactive-- hide\n", "# Predicate logic\n## Level 3: Universal and Existential Quantifiers\n\nMany statements involve universal and existential quantiffiers.\n\nexample: for all integers $x$, there exists an integer $y$, such that $x + y = x + 3$\n\nwe first assume an abitrary integer $x$, then use 3 as the value of $y$, leaving us to prove $x + 3 = x + 3$ which is true by reflexivity.\n\nLean proof is below.\n", "example : \u2200 (x : \u2124), \u2203 (y : \u2124), x + y = x + 3 :=\nbegin\nassume x: \u2124,\nuse 3,\nend \n", "namespace exlean -- hide\n", "## Task\n1. Replace `sorry` below with a Lean proof using both 'assume' and `use'\n", "for all integers $x$, there exists an integer $y$, such that $x + 1 = y$\n", "end exlean -- hide\n"]]}